*carbon* *carbon.txt* *carbon.nvim.txt*

  `Version: 0.1.0`
  `Licence: MIT`
  `Source:  https://github.com/SidOfc/carbon.nvim`
  `Author:  Sidney Liebrand <sidneyliebrand@gmail.com>`

  Carbon is a simple directory tree viewer for Neovim written in Lua.

================================================================================
TABLE OF CONTENTS                                     *carbon-contents* *carbon-toc*

  To quickly jump to this table of contents, use |gg| or |go|.
  To navigate to the helptag below the cursor, use CTRL-].

  TABLE OF CONTENTS `.........` |carbon-contents|
  USAGE `.....................` |carbon-usage|
  SETUP `.....................` |carbon-setup|
  COMMANDS `..................` |carbon-commands|
  PLUGS `.....................` |carbon-plugs|
  UTIL `......................` |carbon-util|
  ENTRY `.....................` |carbon-entry|
  BUFFER `....................` |carbon-buffer|
  WATCHER `...................` |carbon-watcher|
  SETTINGS `..................` |carbon-settings|

================================================================================
USAGE                                                               *carbon-usage*

  Carbon automatically replaces |netrw| and remaps NetRW's |Explore| and
  |Lexplore| commands to Carbon's |Carbon| and |Lcarbon| commands respectively.

  For more specific usage and configuration information, see:

  - |carbon-commands| for command details.
  - |carbon-plugs| for mapping details.
  - |carbon-setup| for configuration details.

================================================================================
SETUP                                                               *carbon-setup*

  The behavior of this plugin can be customized by calling
  `require('carbon').setup` in your |$MYVIMRC| like this:

  init.lua:
  `require('carbon').setup({`
  `  setting = 'value',`
  `})`

  init.vim:
  `lua << EOF`
  `  require('carbon').setup({`
  `    setting = 'value',`
  `  })`
  `EOF`

  If setting options directly is preferred, passing a function is also possible:

  init.lua:
  `require('carbon').setup(function(settings)`
  `  settings.setting = 'value',`
  `end)`

  init.vim:
  `lua << EOF`
  `  require('carbon').setup(function(settings)`
  `    settings.setting = 'value',`
  `  end)`
  `EOF`

  The default settings are documented in |carbon-settings|. Any settings
  supplied to `setup` when called with a table will be deep merged with
  the defaults. When `setup` is called with a function argument, settings
  are directly modified and no merging of any kind will occur.

================================================================================
COMMANDS                                                         *carbon-commands*

  This section documents the behavior as well as the implementation of the
  various |command| commands provided by Carbon.

  `------------------------------------------------------------------------------`
  Carbon                                                                  *Carbon*

  Implementation: `:lua require('carbon').explore()`
  Alias:          Explore unless |carbon-setting-keep-netrw| is enabled.

  This command replaces the current buffer with the Carbon buffer.

  `------------------------------------------------------------------------------`
  Lcarbon                                                                *Lcarbon*

  Implementation: `:lua require('carbon').explore_left()`
  Alias:          Lexplore unless |carbon-setting-keep-netrw| is enabled.

  Opens the Carbon buffer in a new vertical split. When Carbon is opened this
  way, pressing the key mapped to |carbon-plug-edit| will open files in a
  split directly to the right.

================================================================================
PLUGS                                                               *carbon-plugs*

  Documentation for the default |<Plug>| mappings that Carbon provides.
  |<Plug>| mappings are created unconditionally.

  `------------------------------------------------------------------------------`
  <plug>(carbon-up)                                               *carbon-plug-up*

  Implementation: `:<c-u>lua require('carbon').up()<cr>`
  Mapping:        |carbon-setting-actions-up|

  Sets Carbon's root to the parent directory of the current working directory.
  Accepts a [count].

  `------------------------------------------------------------------------------`
  <plug>(carbon-down)                                           *carbon-plug-down*

  Implementation: `:<c-u>lua require('carbon').down()<cr>`
  Mapping:        |carbon-setting-actions-down|

  Sets Carbon's root to the directory under the cursor. If the entry under the
  cursor is a file then the parent directory of the file's path will be used.
  Accepts a [count] to allow navigating deeper into compressed paths.

  `------------------------------------------------------------------------------`
  <plug>(carbon-edit)                                           *carbon-plug-edit*

  Implementation: `:<c-u>lua require('carbon').edit()<cr>`
  Mapping:        |carbon-setting-actions-edit|

  If the entry below the cursor is a directory, opens or closes the
  directory. Otherwise the file is opened in the current window unless the
  |Lcarbon| command was used.

  `------------------------------------------------------------------------------`
  <plug>(carbon-reset)                                         *carbon-plug-reset*

  Implementation: `:<c-u>lua require('carbon').reset()<cr>`
  Mapping:        |carbon-setting-actions-reset|

  Sets Carbon's root to the initial directory that Neovim was opened with.

  `------------------------------------------------------------------------------`
  <plug>(carbon-split)                                         *carbon-plug-split*

  Implementation: `:<c-u>lua require('carbon').split()<cr>`
  Mapping:        |carbon-setting-actions-split|

  Opens the entry below the cursor in a new |split| if it is a file. If the
  entry is a directory then nothing happens.

  `------------------------------------------------------------------------------`
  <plug>(carbon-vsplit)                                       *carbon-plug-vsplit*

  Implementation: `:<c-u>lua require('carbon').vsplit()<cr>`
  Mapping:        |carbon-setting-actions-vsplit|

  Opens the entry below the cursor in a new |vsplit| if it is a file. If the
  entry is a directory then nothing happens.

================================================================================
UTIL                                                                 *carbon-util*

  Usage: `require('carbon.util')`

  This sections describes the internal utilities used by Carbon itself. These
  methods must always be considered unstable and should not be used in code
  external to Carbon.

  `------------------------------------------------------------------------------`
  plug                                                          *carbon-util-plug*

  `require('carbon.util').plug(`{name}`)`

  Converts {name} to a |<Plug>| map string. For example calling
  `require('carbon.util').plug('up')` will return the string `'<plug>(carbon-up)'`.

  This function fails when {name} is not a string.

  `------------------------------------------------------------------------------`
  tbl_find                                                  *carbon-util-tbl-find*

  `require('carbon.util').tbl_find(`{tbl}, {callback}`)`

  Execute `callback(`{value}, {key}`)` for each value in {tbl} until {callback}
  returns a truthy value. When {callback} returns true, return {value} and
  {key}. When no item is found, return `nil`.

  This function fails when {tbl} is not a table or when
  {callback} is not callable.

  `------------------------------------------------------------------------------`
  tbl_except                                              *carbon-util-tbl-except*

  `require('carbon.util').tbl_except(`{tbl}, {keys}`)`

  Return a new table with all keys from {tbl} except
  those specified in {keys}.

  This function fails when either {tbl} or {keys} is not a table.

  `------------------------------------------------------------------------------`
  map                                                            *carbon-util-map*

  `require('carbon.util').map(`{lhs}, {rhs}[, {options}]`)`

  Wraps |nvim_set_keymap| and |nvim_buf_set_keymap|. Maps {lhs} to
  {rhs}. An optional {options} table can supplied. It accepts the same
  options as |nvim_set_keymap| does and also supports two extra options:
  `mode` which defaults to `'n'` and `buffer` which defaults to `nil`.

  To create a |Visual| mapping pass `mode = 'v'`, to create a buffer-local
  mapping pass `buffer = <bufnr>` where `<bufnr>` is a |bufnr()|.

  The `mode` and `buffer` options are not passed to |nvim_set_keymap|
  functions because they are explicitly filtered out for internal use by the
  map utility function. All other {options} keys will be passed through.

  This function fails when {lhs} or {rhs} are not strings or if {options} is
  provided but not a table.

  `------------------------------------------------------------------------------`
  command                                                    *carbon-util-command*

  `require('carbon.util').command(`{lhs}, {rhs}[, {options}]`)`

  Wraps |nvim_add_user_command|. The only difference between this
  function and |nvim_add_user_command| is that the {options} argument is
  optional, when not passed it will default to an empty table.

  This function fails when {lhs} or {rhs} are not strings or if {options} is
  provided but not a table.

  `------------------------------------------------------------------------------`
  highlight                                                *carbon-util-highlight*

  `require('carbon.util').highlight(`{group}, {properties}`)`

  Builds a |highlight| command for {group} using provided {properties} and
  executes that command. {group} will be the highlight group name. {properties}
  is a table accepting any properties that can be passed to |highlight|.

  This function fails when {group} is not a string or when {properties}
  is not a table.

================================================================================
ENTRY                                                               *carbon-entry*

  Usage: `require('carbon.entry')`

  Provides a consistent interface for working with files and directories and
  includes methods for fetching, caching, sorting, watching, and unwatching
  entries. See |carbon-entry-new| for details on entry objects, a term which
  will be used throughout this section to refer to entry instance objects.

  NOTE:
  static methods of this module are called using dot-syntax (`.`) whereas
  instance methods of this module are called using colon-syntax (`:`). This
  difference is visible in the function signature of each method.

  `------------------------------------------------------------------------------`
  new                                                           *carbon-entry-new*

  Signature: `require('carbon.entry').new(`{path}[, {parent}]`)`

  Returns a new entry object for provided absolute {path}. The {path}
  parameter must be a string. {path} may point to files as well as
  directories. When {parent} is supplied, it is set as the entry object's
  `parent` property. {parent} must be another entry object if provided.

  The returned entry object has the following shape:

  `{`
  `  path = '/absolute/path/to/file-or-dir',`
  `  name = 'file-or-dir',`
  `  is_directory = false,`
  `  is_executable = false,`
  `  is_symlink = nil,`
  `}`

  - `path` is the absolute {path}.
  - `name` is the tail of given {path} as returned by |fnamemodify| `:t`.
  - `is_directory` is `true` when |isdirectory| equals `1`.
  - `is_executable` is `true` when |isdirectory| equals `0` and |executable| equals `1`.
  - `is_symlink` is:
    - `2` when {path} does not equal |resolve| of {path} and |getftime| equals `-1`.
    - `1` when {path} does not equal |resolve| of {path} and |getftime| is not `-1`.
    - `nil` otherwise.

  For `is_symlink`, a value of `2` indicates a broken symlink, a value of `1`
  indicates a valid symlink, and `nil` is used when {path} is not a symlink.

  The following methods can be called on entries:

  - |carbon-entry-synchronize|
  - |carbon-entry-children|
  - |carbon-entry-has-children|
  - |carbon-entry-get-children|
  - |carbon-entry-set-children|

  For example: `require('carbon.entry').new('/'):children()` will return a
  table with the direct children of `/` as entry objects.

  This function will fail if {path} is not a path to an existing file or
  directory and passing a {parent} that is not an entry object created via
  `require('carbon.entry').new()` will lead to fatal rendering errors.

  `------------------------------------------------------------------------------`
  find                                                         *carbon-entry-find*

  Signature: `require('carbon.entry').find(`{path}`)`

  Used to find the entry object associated with {path}. The {path} entry must
  already be loaded by Carbon for this to work. That is, it only finds
  children that have already been loaded by Carbon.

  When an entry object matches {path} it is returned, otherwise the return
  value will be `nil`. This function will not fail if {path} is not a string!

  For more information about entry objects, see: |carbon-entry-new|.

  `------------------------------------------------------------------------------`
  clean                                                       *carbon-entry-clean*

  Signature: `require('carbon.entry').clean(`{path}`)`

  Removes all parent and sibling files and directories from the internal
  children cache used by Carbon. Also removes watchers from all removed
  children.

  WARNING:
  It is not recommended to call this method manually because it
  has a high likelyhood of breaking Carbon if not used with caution. It is
  only documented for completeness.

  `------------------------------------------------------------------------------`
  synchronize                                           *carbon-entry-synchronize*

  Signature: `entry:synchronize()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  When `entry.is_directory` is `true`, synchronizes all its children with the
  current state of the file system recursively. Files and folders that were
  added, removed, renamed, or had their permissions changed within `entry.path`
  will be refreshed.

  When `entry.is_directory` is `false`, nothing happens because Carbon only
  listens to changes to and within directories.

  `------------------------------------------------------------------------------`
  children                                                 *carbon-entry-children*

  Signature: `entry:children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  When `entry.is_directory` is true, fetches children using
  |carbon-entry-get-children| and caches them. Always returns a table with
  child entry objects or an empty table if it has no children such as regular
  files and empty directories.

  `------------------------------------------------------------------------------`
  has_children                                         *carbon-entry-has-children*

  Signature: `entry:has_children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns `true` when children of `entry.path` have already been cached.
  Returns `false` otherwise.

  `------------------------------------------------------------------------------`
  set_children                                         *carbon-entry-set-children*

  Signature: `entry:set_children(`{children}`)`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Set the cached children of `entry.path` to {children}. The {children} must
  be a table with entry object elements or `nil`.

  When {children} is `nil` the next call to |carbon-entry-children| will
  result in a fresh listing directly from the file system.

  `------------------------------------------------------------------------------`
  get_children                                         *carbon-entry-get-children*

  Signature: `entry:get_children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns a table of entry object elements by calling |readdir| on `entry.path`.
  The entry objects will be direct children of `entry.path`. The table will be
  sorted in case-insensitive alphabetical order and all directories will come
  before any files.

  Paths matching any of the patterns defined in |carbon-setting-exclude| will
  be excluded from the returned table.

================================================================================
BUFFER                                                             *carbon-buffer*

  Usage: `require('carbon.buffer')`

  This module is one of Carbon's core modules. It provides methods and
  utilities to show the directory tree, interact with it, and keep it
  synchronized with changes from the file system.

                                                         *carbon-buffer-data-root*

  The following sections may refer to a `data.root` entry object.
  This `data.root` variable is local and private to this module. It is set to
  a |carbon-entry-new| created with the value of |getcwd()| as only argument.

  This variable is the internal representation of the file tree which functions
  such as |carbon-buffer-lines| can use as a data source or functions like
  |carbon-buffer-up|, |carbon-buffer-down|, |carbon-buffer-reset|, or
  |carbon-buffer-cd| can manipulate to enable navigating up from the current
  working directory, down into a child, reset back to the original
  directory Neovim was opened with, or set to an arbitrary path.

  `------------------------------------------------------------------------------`
  handle                                                    *carbon-buffer-handle*

  Signature: `require('carbon.buffer').handle()`

  Checks the current buffer handle and if valid, returns it. Otherwise creates
  and configures a new buffer, updates the current buffer handle and returns
  the new buffer handle.

  The buffer name will always be `'carbon'` and the following buffer-local
  options are always set:

  |swapfile|    =>  `false`
  |filetype|    =>  `'carbon'`
  |bufhidden|   =>  `'hide'`
  |buftype|     =>  `'nofile'`
  |modifiable|  =>  `false`

  Finally, if there are actions to map in |carbon-setting-actions| then they
  will be mapped locally to this buffer to a |<Plug>| mapping with the
  same suffix from |carbon-plugs|.

  `------------------------------------------------------------------------------`
  show                                                        *carbon-buffer-show*

  Signature: `require('carbon.buffer').show()`

  Show the Carbon buffer in the current window. Triggers a |carbon-buffer-render|.

  `------------------------------------------------------------------------------`
  render                                                    *carbon-buffer-render*

  Signature: `require('carbon.buffer').render()`

  Renders the Carbon buffer. The contents are determined by calling the
  |carbon-buffer-lines| method with the `data.root` entry object as only
  argument. See |carbon-buffer-data-root| for more information about `data.root`.

  `------------------------------------------------------------------------------`
  cursor                                                    *carbon-buffer-cursor*

  Signature: `require('carbon.buffer').cursor()`

  Returns the result at index `line('.')` from |carbon-buffer-lines| called with
  |carbon-buffer-data-root| as only argument.

  `------------------------------------------------------------------------------`
  lines                                                      *carbon-buffer-lines*

  Signature: `require('carbon.buffer').lines(`{entry}[, {lines}[, {depth}]]`)`

  The {entry} argument must be an entry object as returned by |carbon-entry-new|.
  The {lines} argument is optional. Defaults to an empty table `{}`.
  When {lines} is set to a table, this table will be used instead as accumulator
  for the results. Finally, the optional {depth} argument can be used to specify
  the initial indentation level. Defaults to `0`.

  Returns a table of "line objects" to render. A "line object" has the
  following data layout:

  `{`
  `  entry = `{entry}`,`
  `  line = <string>,`
  `  highlights = <table<table<string, number, number>>>,`
  `  path = <table<string>>,`
  `}`

  Property: `entry`

  The {entry} which was used to generate the `line`, `highlights`,
  and `path` property values.

  Property: `line`

  This property is set to the text that should be rendered to the buffer.

  Property: `highlights`

  The `highlights` property provides zero or more highlights for the current
  {entry}. A highlight in this context is a table with the following structure:

  `{`
  `  <string HighlightGroupName>,`
  `  <number start_column>,`
  `  <number end_column>,`
  `}`

  |carbon-buffer-render| uses |nvim_buf_add_highlight| to set the highlights.
  It is called the following way:

  `vim.api.nvim_buf_add_highlight(`
  `  buffer.handle(),`
  `  data.namespace,`
  `  highlight[1],` => `<string HighlightGroupName>`
  `  lnum - 1,`
  `  highlight[2],` => `<number start_column>`
  `  highlight[3],` => `<number end_column>`
  `)`

  Property: `path`

  When |carbon-setting-compress| is enabled, this table is filled with the
  compressed parent entry objects of `entry`.

  `------------------------------------------------------------------------------`
  synchronize                                          *carbon-buffer-synchronize*

  Signature: `require('carbon.buffer').synchronize()`

  Calls |carbon-entry-synchronize| on |carbon-buffer-data-root| and calls
  |carbon-buffer-render| afterwards.

  `------------------------------------------------------------------------------`
  up                                                            *carbon-buffer-up*

  Signature: `require('carbon.buffer').up(`[{count}]`)`

  Set |carbon-buffer-data-root| to its {count}th parent directory. When {count}
  is not supplied, it will use `vim.v.count1` which defaults to `1` or [count] if
  specified while executing this method in a mapping.

  This method moves the root up one level at a time. It queries the children
  of the parent and replaces the child with the same path as the current
  `data.root` with `data.root`. It also sets `data.root` to an open state so
  when "zooming out" you still see what you had open.

  After doing all this, the `data.root` is finally set to the actual parent.
  This routine then is repeated {count} `- 1` more times.

  Returns `true` if the root is replaced at least once. `nil` otherwise. This
  can happen when you are at your OS root directory and try to go up more.

  `------------------------------------------------------------------------------`
  down                                                        *carbon-buffer-down*

  Signature: `require('carbon.buffer').down(`[{count}]`)`

  Set |carbon-buffer-data-root| to its {count}th child directory below the
  cursor. When {count} is not supplied, it will use `vim.v.count1` which defaults
  to `1` or [count] if specified while executing this method in a mapping.

  Specifying a {count} is only useful when the cursor is on a compressed path.
  The |carbon-setting-compress| section explains how compressed paths work.

  With the cursor on this path `a/b/c/d/e.txt`, calling this method without
  specifying a {count} will move the root to `/a`, you will now see the path
  `b/c/d/e.txt`. If you call the method again, but this time you supply `2` as
  {count} you will navigate "past" `c/` directly into `d/`. You will now only
  see `e.txt`.

  Returns `true` when the root is replaced, `nil` when the `new_root` path is the
  same as the current `data.root` path in which case the root is not replaced.

  `------------------------------------------------------------------------------`
  cd                                                            *carbon-buffer-cd*

  Signature: `require('carbon.buffer').cd(`{path}`)`

  Set |carbon-buffer-data-root| to a |carbon-entry-new| created using {path}.
  This method remembers the state of all child directories when navigating up
  directories. When navigating to a child of the current working directory
  Carbon tries look for any children in its own state to jump to without
  having to perform additional file system reads. In any other case, Carbon
  navigates to the {path} entry object.

  `------------------------------------------------------------------------------`
  reset                                                      *carbon-buffer-reset*

  Signature: `require('carbon.buffer').reset()`

  Set |carbon-buffer-data-root| to the original |pwd| using |carbon-buffer-cd|.

================================================================================
WATCHER                                                           *carbon-watcher*

  `------------------------------------------------------------------------------`
  on                                                           *carbon-watcher-on*

  `------------------------------------------------------------------------------`
  off                                                         *carbon-watcher-off*

  `------------------------------------------------------------------------------`
  emit                                                       *carbon-watcher-emit*

  `------------------------------------------------------------------------------`
  clear                                                     *carbon-watcher-clear*

  `------------------------------------------------------------------------------`
  release                                                 *carbon-watcher-release*

  `------------------------------------------------------------------------------`
  register                                               *carbon-watcher-register*

================================================================================
SETTINGS                                                         *carbon-settings*

  `------------------------------------------------------------------------------`
  compress                                               *carbon-setting-compress*

  `------------------------------------------------------------------------------`
  auto_open                                             *carbon-setting-auto-open*

  `------------------------------------------------------------------------------`
  keep_netrw                                           *carbon-setting-keep-netrw*

  `------------------------------------------------------------------------------`
  sync_on-cd                                           *carbon-setting-sync-on-cd*

  `------------------------------------------------------------------------------`
  sync_delay                                           *carbon-setting-sync-delay*

  `------------------------------------------------------------------------------`
  sidebar_width                                     *carbon-setting-sidebar-width*

  `------------------------------------------------------------------------------`
  exclude                                                 *carbon-setting-exclude*

  `------------------------------------------------------------------------------`
  indicators                                           *carbon-setting-indicators*

  `------------------------------------------------------------------------------`
  actions                                                 *carbon-setting-actions*

  `------------------------------------------------------------------------------`
  highlights                                           *carbon-setting-highlights*
