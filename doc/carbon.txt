*carbon.nvim.txt*       The simple directory tree viewer for Neovim written in Lua.
*carbon.txt*

  `Version: 0.1.0`
  `Licence: MIT`
  `Source:  https://github.com/SidOfc/carbon.nvim`
  `Author:  Sidney Liebrand <sidneyliebrand@gmail.com>`

================================================================================
TABLE OF CONTENTS                                     *carbon-contents* *carbon-toc*

  To quickly jump to this table of contents, use |gg| or |go|.
  To navigate to the helptag below the cursor, use CTRL-].

  TABLE OF CONTENTS `.........` |carbon-contents|
  USAGE `.....................` |carbon-usage|
  SETUP `.....................` |carbon-setup|
  COMMANDS `..................` |carbon-commands|
  PLUGS `.....................` |carbon-plugs|
  CARBON `....................` |carbon-carbon|
  UTIL `......................` |carbon-util|
  ENTRY `.....................` |carbon-entry|
  BUFFER `....................` |carbon-buffer|
  WATCHER `...................` |carbon-watcher|
  SETTINGS `..................` |carbon-settings|

================================================================================
USAGE                                                               *carbon-usage*

  Carbon automatically replaces |netrw| and remaps NetRW's |Explore| and
  |Lexplore| commands to Carbon's |Carbon| and |Lcarbon| commands respectively.

  For more specific usage and configuration information, see:

  - |carbon-commands| for command details.
  - |carbon-plugs| for mapping details.
  - |carbon-setup| for configuration details.

================================================================================
SETUP                                                               *carbon-setup*

  The behavior of this plugin can be customized by calling
  `require('carbon').setup` in your |$MYVIMRC| like this:

  init.lua:
  `require('carbon').setup({`
  `  setting = 'value',`
  `})`

  init.vim:
  `lua << EOF`
  `  require('carbon').setup({`
  `    setting = 'value',`
  `  })`
  `EOF`

  If setting options directly is preferred, passing a function is also possible:

  init.lua:
  `require('carbon').setup(function(settings)`
  `  settings.setting = 'value',`
  `end)`

  init.vim:
  `lua << EOF`
  `  require('carbon').setup(function(settings)`
  `    settings.setting = 'value',`
  `  end)`
  `EOF`

  The default settings are documented in |carbon-settings|. Any settings
  supplied to `setup` when called with a table will be deep merged with
  the defaults. When `setup` is called with a function argument, settings
  are directly modified and no merging of any kind will occur.

================================================================================
COMMANDS                                                         *carbon-commands*

  This section documents the behavior as well as the implementation of the
  various |command| commands provided by Carbon.

  `------------------------------------------------------------------------------`
  Carbon                                                                  *Carbon*

  Implementation: `:lua require('carbon').explore()`
  Alias:          Explore unless |carbon-setting-keep-netrw| is enabled.

  This command replaces the current buffer with the Carbon buffer.

  `------------------------------------------------------------------------------`
  Lcarbon                                                                *Lcarbon*

  Implementation: `:lua require('carbon').explore_left()`
  Alias:          Lexplore unless |carbon-setting-keep-netrw| is enabled.

  Opens the Carbon buffer in a new vertical split. When Carbon is opened this
  way, pressing the key mapped to |carbon-plug-edit| will open files in a
  split directly to the right.

================================================================================
PLUGS                                                               *carbon-plugs*

  Documentation for the default |<Plug>| mappings that Carbon provides.
  |<Plug>| mappings are created unconditionally.

  `------------------------------------------------------------------------------`
  <plug>(carbon-up)                                               *carbon-plug-up*

  Implementation: `:<c-u>lua require('carbon').up()<cr>`
  Mapping:        |carbon-setting-actions-up|

  Sets |carbon-buffer-data-root| to the parent directory of the current
  working directory. Accepts a [count].

  `------------------------------------------------------------------------------`
  <plug>(carbon-down)                                           *carbon-plug-down*

  Implementation: `:<c-u>lua require('carbon').down()<cr>`
  Mapping:        |carbon-setting-actions-down|

  Sets |carbon-buffer-data-root| to the directory under the cursor. If the entry
  under the cursor is a file then the parent directory of the file's path will
  be used. Accepts a [count] to allow navigating deeper into compressed paths.

  `------------------------------------------------------------------------------`
  <plug>(carbon-reset)                                         *carbon-plug-reset*

  Implementation: `:<c-u>lua require('carbon').reset()<cr>`
  Mapping:        |carbon-setting-actions-reset|

  Sets |carbon-buffer-data-root| to the initial directory that Neovim
  was opened with.

  `------------------------------------------------------------------------------`
  <plug>(carbon-edit)                                           *carbon-plug-edit*

  Implementation: `:<c-u>lua require('carbon').edit()<cr>`
  Mapping:        |carbon-setting-actions-edit|

  If the entry below the cursor is a directory, opens or closes the
  directory. Otherwise the file is opened in the current window unless the
  |Lcarbon| command was used.

  `------------------------------------------------------------------------------`
  <plug>(carbon-split)                                         *carbon-plug-split*

  Implementation: `:<c-u>lua require('carbon').split()<cr>`
  Mapping:        |carbon-setting-actions-split|

  Opens the entry below the cursor in a new |split| if it is a file. If the
  entry is a directory then nothing happens.

  `------------------------------------------------------------------------------`
  <plug>(carbon-vsplit)                                       *carbon-plug-vsplit*

  Implementation: `:<c-u>lua require('carbon').vsplit()<cr>`
  Mapping:        |carbon-setting-actions-vsplit|

  Opens the entry below the cursor in a new |vsplit| if it is a file. If the
  entry is a directory then nothing happens.

================================================================================
CARBON                                                             *carbon-carbon*

  Usage: `require('carbon')`

  `------------------------------------------------------------------------------`
  setup                                                      *carbon-carbon-setup*

  Signature: `require('carbon').setup(`{preferences}`)`

  This method updates Carbon's |carbon-settings| with user {preferences}.
  The {preferences} argument can be a table which will be deep-merged with
  |carbon-settings-table| or a callback function which accepts
  |carbon-settings-table| as argument. The callback can modify the settings
  freely. See |carbon-setup| for init.vim / init.lua setup call examples.

  `------------------------------------------------------------------------------`
  initialize                                            *carbon-carbon-initialize*

  Signature: `require('carbon').initialize()`

  Initializes Carbon. This method creates |carbon-commands|, |carbon-plugs|,
  autocommands, and highlights. It hijacks NetRW depending on the value of
  |carbon-setting-keep-netrw| and automatically opens the Carbon buffer if
  Neovim was opened with a directory path depending on |carbon-setting-auto-open|.

  This method must be called before the buffer is created otherwise the buffer
  will not function properly.

  `------------------------------------------------------------------------------`
  edit                                                        *carbon-carbon-edit*

  Signature: `require('carbon').edit()`

  If the entry which the cursor is on is a directory then this method expands
  or collapses it depending on its current state. If it is a file and the
  current buffer was opened using |carbon-carbon-explore-left| then the file will
  be opened in a new split to the right. A split will be created if it does not
  exist. Otherwise if it is a file it will be edited in the current window.

  `------------------------------------------------------------------------------`
  split                                                      *carbon-carbon-split*

  Signature: `require('carbon').split()`

  If the entry which the cursor is on is a directory then this will result in
  a no-op. If it is a file it will be opened in a horizontal split. Respects
  your |splitbelow| preference.

  `------------------------------------------------------------------------------`
  vsplit                                                    *carbon-carbon-vsplit*

  Signature: `require('carbon').vsplit()`

  Like |carbon-carbon-split| but instead of a horizontal split, opens a
  vertical split. Respects your |splitright| preference.

  `------------------------------------------------------------------------------`
  explore                                                  *carbon-carbon-explore*

  Signature: `require('carbon').explore()`

  Show Carbon in the current window. Calls |carbon-buffer-show| internally.
  Used by the |Carbon| command.

  `------------------------------------------------------------------------------`
  explore_left                                        *carbon-carbon-explore-left*

  Signature: `require('carbon').explore_left()`

  Show Carbon in a new vertical split on the left side with a width of
  |carbon-setting-sidebar-width|. Used by the |Lcarbon| command and modifies how
  |carbon-carbon-edit| works for that window.

  `------------------------------------------------------------------------------`
  up                                                            *carbon-carbon-up*

  Signature: `require('carbon').up()`

  Calls |carbon-buffer-up|. When the |buffer-data-root| is updated
  successfully, this method will move the cursor to the top of the buffer and
  rerender.

  `------------------------------------------------------------------------------`
  reset                                                      *carbon-carbon-reset*

  Signature: `require('carbon').reset()`

  Calls |carbon-buffer-reset|. When the |carbon-buffer-data-root| is updated
  successfully, this method will move the cursor to the top of the buffer and
  rerender.

  `------------------------------------------------------------------------------`
  down                                                        *carbon-carbon-down*

  Signature: `require('carbon').down()`

  Calls |carbon-buffer-down|. When the |carbon-buffer-data-root| is updated
  successfully, this method will move the cursor to the top of the buffer and
  rerender.

  `------------------------------------------------------------------------------`
  cd                                                            *carbon-carbon-cd*

  Signature: `require('carbon').cd(`[{path}]`)`

  Calls |carbon-buffer-cd| to set |carbon-buffer-data-root| to {path}. If {path}
  is not supplied then |vim.v| variable `vim.v.event.cwd` will be used. When updated
  successfully, this method will move the cursor to the top of the buffer
  and rerender.

================================================================================
UTIL                                                                 *carbon-util*

  Usage: `require('carbon.util')`

  This sections describes the internal utilities used by Carbon itself. These
  methods must always be considered unstable and should not be used in code
  external to Carbon.

  `------------------------------------------------------------------------------`
  plug                                                          *carbon-util-plug*

  `require('carbon.util').plug(`{name}`)`

  Converts {name} to a |<Plug>| map string. For example calling
  `require('carbon.util').plug('up')` will return the string `'<plug>(carbon-up)'`.

  This function fails when {name} is not a string.

  `------------------------------------------------------------------------------`
  tbl_find                                                  *carbon-util-tbl-find*

  `require('carbon.util').tbl_find(`{tbl}, {callback}`)`

  Execute `callback(`{value}, {key}`)` for each value in {tbl} until {callback}
  returns a truthy value. When {callback} returns true, return {value} and
  {key}. When no item is found, return `nil`.

  This function fails when {tbl} is not a table or when
  {callback} is not callable.

  `------------------------------------------------------------------------------`
  tbl_except                                              *carbon-util-tbl-except*

  `require('carbon.util').tbl_except(`{tbl}, {keys}`)`

  Return a new table with all keys from {tbl} except
  those specified in {keys}.

  This function fails when either {tbl} or {keys} is not a table.

  `------------------------------------------------------------------------------`
  map                                                            *carbon-util-map*

  `require('carbon.util').map(`{lhs}, {rhs}[, {options}]`)`

  Wraps |nvim_set_keymap| and |nvim_buf_set_keymap|. Maps {lhs} to {rhs}.
  An optional {options} table can supplied. It accepts the same options
  as |nvim_set_keymap| does and also supports two extra options: `mode` which
  defaults to `'n'` and `buffer` which defaults to `nil`.

  {lhs} must be a string containing the key for this mapping.
  {rhs} must be a vim command string or a function.

  When a function is passed to {rhs}, it is pushed to a table local to the
  util module. The {rhs} is then replaced with a sequence which calls
  |carbon-util-map-callback| with the correct index. For example:

  `require('carbon.util').map(`"n", function() print("hello") end`)`

  Will map the key `"n"` to:

  `:<c-u>lua require("carbon.util").map_callback(1)<cr>`

  To create a |Visual| mapping pass `mode = 'v'`, to create a buffer-local
  mapping pass `buffer = <bufnr>` where `<bufnr>` is a |bufnr()|.

  The `mode` and `buffer` options are not passed to |nvim_set_keymap|
  functions because they are explicitly filtered out for internal use by the
  map utility function. All other {options} keys will be passed through.

  This function fails when {lhs} is not a string or {rhs} is not a string or
  function or if {options} is provided but not a table.

  `------------------------------------------------------------------------------`
  map_callback                                          *carbon-util-map-callback*

  Signature: `require('carbon.util').map_callback(`{index}`)`

  Calls the function stored at {index}. The |carbon-util-map| method uses this
  method to be able to accept callback functions.

  `------------------------------------------------------------------------------`
  command                                                    *carbon-util-command*

  `require('carbon.util').command(`{lhs}, {rhs}[, {options}]`)`

  Wraps |nvim_add_user_command|. The only difference between this
  function and |nvim_add_user_command| is that the {options} argument is
  optional, when not passed it will default to an empty table.

  This function fails when {lhs} or {rhs} are not strings or if {options} is
  provided but not a table.

  `------------------------------------------------------------------------------`
  highlight                                                *carbon-util-highlight*

  `require('carbon.util').highlight(`{group}, {properties}`)`

  Builds a |highlight| command for {group} using provided {properties} and
  executes that command. {group} will be the highlight group name. {properties}
  is a table accepting any properties that can be passed to |highlight|.

  This function fails when {group} is not a string or when {properties}
  is not a table.

================================================================================
ENTRY                                                               *carbon-entry*

  Usage: `require('carbon.entry')`

  Provides a consistent interface for working with files and directories and
  includes methods for fetching, caching, sorting, watching, and unwatching
  entries. See |carbon-entry-new| for details on entry objects, a term which
  will be used throughout this section to refer to entry instance objects.

  NOTE:
  static methods of this module are called using dot-syntax (`.`) whereas
  instance methods of this module are called using colon-syntax (`:`). This
  difference is visible in the function signature of each method.

  `------------------------------------------------------------------------------`
  new                                                           *carbon-entry-new*

  Signature: `require('carbon.entry').new(`{path}[, {parent}]`)`

  Returns a new entry object for provided absolute {path}. The {path}
  parameter must be a string. {path} may point to files as well as
  directories. When {parent} is supplied, it is set as the entry object's
  `parent` property. {parent} must be another entry object if provided.

  The returned entry object has the following shape:

  `{`
  `  path = '/absolute/path/to/file-or-dir',`
  `  name = 'file-or-dir',`
  `  is_directory = false,`
  `  is_executable = false,`
  `  is_symlink = nil,`
  `}`

  - `path` is the absolute {path}.
  - `name` is the tail of given {path} as returned by |fnamemodify| `:t`.
  - `is_directory` is `true` when |isdirectory| equals `1`.
  - `is_executable` is `true` when |isdirectory| equals `0` and |executable| equals `1`.
  - `is_symlink` is:
    - `2` when {path} does not equal |resolve| of {path} and |getftime| equals `-1`.
    - `1` when {path} does not equal |resolve| of {path} and |getftime| is not `-1`.
    - `nil` otherwise.

  For `is_symlink`, a value of `2` indicates a broken symlink, a value of `1`
  indicates a valid symlink, and `nil` is used when {path} is not a symlink.

  The following methods can be called on entries:

  - |carbon-entry-synchronize|
  - |carbon-entry-children|
  - |carbon-entry-has-children|
  - |carbon-entry-get-children|
  - |carbon-entry-set-children|

  For example: `require('carbon.entry').new('/'):children()` will return a
  table with the direct children of `/` as entry objects.

  This function will fail if {path} is not a path to an existing file or
  directory and passing a {parent} that is not an entry object created via
  `require('carbon.entry').new()` will lead to fatal rendering errors.

  `------------------------------------------------------------------------------`
  find                                                         *carbon-entry-find*

  Signature: `require('carbon.entry').find(`{path}`)`

  Used to find the entry object associated with {path}. The {path} entry must
  already be loaded by Carbon for this to work. That is, it only finds
  children that have already been loaded by Carbon.

  When an entry object matches {path} it is returned, otherwise the return
  value will be `nil`. This function will not fail if {path} is not a string!

  For more information about entry objects, see: |carbon-entry-new|.

  `------------------------------------------------------------------------------`
  clean                                                       *carbon-entry-clean*

  Signature: `require('carbon.entry').clean(`{path}`)`

  Removes all parent and sibling files and directories from the internal
  children cache used by Carbon. Also removes watchers from all removed
  children.

  WARNING:
  It is not recommended to call this method manually because it
  has a high likelyhood of breaking Carbon if not used with caution. It is
  only documented for completeness.

  `------------------------------------------------------------------------------`
  synchronize                                           *carbon-entry-synchronize*

  Signature: `entry:synchronize()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  When `entry.is_directory` is `true`, synchronizes all its children with the
  current state of the file system recursively. Files and folders that were
  added, removed, renamed, or had their permissions changed within `entry.path`
  will be refreshed.

  When `entry.is_directory` is `false`, nothing happens because Carbon only
  listens to changes to and within directories.

  `------------------------------------------------------------------------------`
  children                                                 *carbon-entry-children*

  Signature: `entry:children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  When `entry.is_directory` is true, fetches children using
  |carbon-entry-get-children| and caches them. Always returns a table with
  child entry objects or an empty table if it has no children such as regular
  files and empty directories.

  `------------------------------------------------------------------------------`
  has_children                                         *carbon-entry-has-children*

  Signature: `entry:has_children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns `true` when children of `entry.path` have already been cached.
  Returns `false` otherwise.

  `------------------------------------------------------------------------------`
  set_children                                         *carbon-entry-set-children*

  Signature: `entry:set_children(`{children}`)`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Set the cached children of `entry.path` to {children}. The {children} must
  be a table with entry object elements or `nil`.

  When {children} is `nil` the next call to |carbon-entry-children| will
  result in a fresh listing directly from the file system.

  `------------------------------------------------------------------------------`
  get_children                                         *carbon-entry-get-children*

  Signature: `entry:get_children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns a table of entry object elements by calling |readdir| on `entry.path`.
  The entry objects will be direct children of `entry.path`. The table will be
  sorted in case-insensitive alphabetical order and all directories will come
  before any files.

  Paths matching any of the patterns defined in |carbon-setting-exclude| will
  be excluded from the returned table.

================================================================================
BUFFER                                                             *carbon-buffer*

  Usage: `require('carbon.buffer')`

  This module is one of Carbon's core modules. It provides methods and
  utilities to show the directory tree, interact with it, and keep it
  synchronized with changes from the file system.

                                                         *carbon-buffer-data-root*

  The following sections may refer to a `data.root` entry object.
  This `data.root` variable is local and private to this module. It is set to
  a |carbon-entry-new| created with the value of |getcwd()| as only argument.

  This variable is the internal representation of the file tree which functions
  such as |carbon-buffer-lines| can use as a data source or functions like
  |carbon-buffer-up|, |carbon-buffer-down|, |carbon-buffer-reset|, or
  |carbon-buffer-cd| can manipulate to enable navigating up from the current
  working directory, down into a child, reset back to the original
  directory Neovim was opened with, or set to an arbitrary path.

  `------------------------------------------------------------------------------`
  handle                                                    *carbon-buffer-handle*

  Signature: `require('carbon.buffer').handle()`

  Checks the current buffer handle and if valid, returns it. Otherwise creates
  and configures a new buffer, updates the current buffer handle and returns
  the new buffer handle.

  The buffer name will always be `'carbon'` and the following buffer-local
  options are always set:

  |swapfile|    =>  `false`
  |filetype|    =>  `'carbon'`
  |bufhidden|   =>  `'hide'`
  |buftype|     =>  `'nofile'`
  |modifiable|  =>  `false`

  Finally, if there are actions to map in |carbon-setting-actions| then they
  will be mapped locally to this buffer to a |<Plug>| mapping with the
  same suffix from |carbon-plugs|.

  `------------------------------------------------------------------------------`
  show                                                        *carbon-buffer-show*

  Signature: `require('carbon.buffer').show()`

  Show the Carbon buffer in the current window. Triggers a |carbon-buffer-render|.

  `------------------------------------------------------------------------------`
  render                                                    *carbon-buffer-render*

  Signature: `require('carbon.buffer').render()`

  Renders the Carbon buffer. The contents are determined by calling the
  |carbon-buffer-lines| method with the `data.root` entry object as only
  argument. See |carbon-buffer-data-root| for more information about `data.root`.

  `------------------------------------------------------------------------------`
  cursor                                                    *carbon-buffer-cursor*

  Signature: `require('carbon.buffer').cursor()`

  Returns the result at index `line('.')` from |carbon-buffer-lines| called with
  |carbon-buffer-data-root| as only argument.

  `------------------------------------------------------------------------------`
  lines                                                      *carbon-buffer-lines*

  Signature: `require('carbon.buffer').lines(`{entry}[, {lines}[, {depth}]]`)`

  The {entry} argument must be an entry object as returned by |carbon-entry-new|.
  The {lines} argument is optional. Defaults to an empty table `{}`.
  When {lines} is set to a table, this table will be used instead as accumulator
  for the results. Finally, the optional {depth} argument can be used to specify
  the initial indentation level. Defaults to `0`.

  Returns a table of "line objects" to render. A "line object" has the
  following data layout:

  `{`
  `  entry = `{entry}`,`
  `  line = <string>,`
  `  highlights = <table<table<string, number, number>>>,`
  `  path = <table<string>>,`
  `}`

  Property: `entry`

  The {entry} which was used to generate the `line`, `highlights`,
  and `path` property values.

  Property: `line`

  This property is set to the text that should be rendered to the buffer.

  Property: `highlights`

  The `highlights` property provides zero or more highlights for the current
  {entry}. A highlight in this context is a table with the following structure:

  `{`
  `  <string HighlightGroupName>,`
  `  <number start_column>,`
  `  <number end_column>,`
  `}`

  |carbon-buffer-render| uses |nvim_buf_add_highlight| to set the highlights.
  It is called the following way:

  `vim.api.nvim_buf_add_highlight(`
  `  buffer.handle(),`
  `  data.namespace,`
  `  highlight[1],` => `<string HighlightGroupName>`
  `  lnum - 1,`
  `  highlight[2],` => `<number start_column>`
  `  highlight[3],` => `<number end_column>`
  `)`

  Property: `path`

  When |carbon-setting-compress| is enabled, this table is filled with the
  compressed parent entry objects of `entry`.

  `------------------------------------------------------------------------------`
  synchronize                                          *carbon-buffer-synchronize*

  Signature: `require('carbon.buffer').synchronize()`

  Calls |carbon-entry-synchronize| on |carbon-buffer-data-root| and calls
  |carbon-buffer-render| afterwards.

  `------------------------------------------------------------------------------`
  up                                                            *carbon-buffer-up*

  Signature: `require('carbon.buffer').up(`[{count}]`)`

  Set |carbon-buffer-data-root| to its {count}th parent directory. When {count}
  is not supplied, it will use `vim.v.count1` which defaults to `1` or [count] if
  specified while executing this method in a mapping.

  This method moves the root up one level at a time. It queries the children
  of the parent and replaces the child with the same path as the current
  `data.root` with `data.root`. It also sets `data.root` to an open state so
  when "zooming out" you still see what you had open.

  After doing all this, the `data.root` is finally set to the actual parent.
  This routine then is repeated {count} `- 1` more times.

  Returns `true` if the root is replaced at least once. `nil` otherwise. This
  can happen when you are at your OS root directory and try to go up more.

  `------------------------------------------------------------------------------`
  down                                                        *carbon-buffer-down*

  Signature: `require('carbon.buffer').down(`[{count}]`)`

  Set |carbon-buffer-data-root| to its {count}th child directory below the
  cursor. When {count} is not supplied, it will use `vim.v.count1` which defaults
  to `1` or [count] if specified while executing this method in a mapping.

  Specifying a {count} is only useful when the cursor is on a compressed path.
  The |carbon-setting-compress| section explains how compressed paths work.

  With the cursor on this path `a/b/c/d/e.txt`, calling this method without
  specifying a {count} will move the root to `/a`, you will now see the path
  `b/c/d/e.txt`. If you call the method again, but this time you supply `2` as
  {count} you will navigate "past" `c/` directly into `d/`. You will now only
  see `e.txt`.

  Returns `true` when the root is replaced, `nil` when the `new_root` path is the
  same as the current `data.root` path in which case the root is not replaced.

  `------------------------------------------------------------------------------`
  cd                                                            *carbon-buffer-cd*

  Signature: `require('carbon.buffer').cd(`{path}`)`

  Set |carbon-buffer-data-root| to a |carbon-entry-new| created using {path}.
  This method remembers the state of all child directories when navigating up
  directories. When navigating to a child of the current working directory
  Carbon tries look for any children in its own state to jump to without
  having to perform additional file system reads. In any other case, Carbon
  navigates to the {path} entry object.

  `------------------------------------------------------------------------------`
  reset                                                      *carbon-buffer-reset*

  Signature: `require('carbon.buffer').reset()`

  Set |carbon-buffer-data-root| to the original |pwd| using |carbon-buffer-cd|.

================================================================================
WATCHER                                                           *carbon-watcher*

  Usage: `require('carbon.watcher')`

  This module provides a thin wrapper around `vim.loop.new_fs_event`, see
  |watch-file| for more information about `vim.loop.new_fs_event`. Paths can
  be registered using |carbon-watcher-register|, once registered, any change
  to that path will cause an event to be emitted. Registered paths can be
  released using |carbon-watcher-release|. Releasing a path will stop the
  watcher for that path.

  If the path parameter of either of these functions is a directory, then that
  directory and all its children files and directories will be listened to.
  Carbon itself only listens to directories to reduce the amount of file
  watching this plugin does. A single watcher is created for each unique
  directory.

  Finally, |carbon-watcher-on| and |carbon-watcher-off| can be used to
  register callbacks on specific events. The possible events that get
  triggered are:

                                                      *carbon-watcher-event-names*

  - `'change-and-rename'`
  - `'change'`
  - `'rename'`

  `------------------------------------------------------------------------------`
  on                                                           *carbon-watcher-on*

  Signature: `require('carbon.watcher').on(`{event}, {callback}`)`

  The {event} parameter can be given in three different forms:

  When {event} is the string `'*'` then attach {callback} to all events listed
  in |carbon-watcher-event-names|. When {event} is a table of one or more
  |carbon-watcher-event-names| then attach {callback} to each listed event.
  Finally, {event} can be one of |carbon-watcher-event-names|. In this case
  {callback} will be attached only to that event.

                                                      *carbon-watcher-on-callback*

  The {callback} argument must be a function. It receives four arguments and
  can be used like this:

  `function my_callback(`{event}, {dirpath}, {filename}, {error}`)`
  `  print(vim.inspect(`{event}, {dirpath}, {filename}, {error}`))`
  `end`

  `require('carbon.watcher').on('*', my_callback)`

  The {event} argument will be one of |carbon-watcher-event-names|, {dirpath}
  will be the absolute path of the parent directory of the affected path,
  {filename} will be the file name of the affected path and finally, {error}
  will be the value as given by |vim.schedule_wrap()| which the watcher module
  uses internally.

  Another important detail is the fact that we did not pass a closure to `on`
  but we passed a function reference. This is important because the reference
  to the function must be reused in `off` to unbind that specific handler. To
  unbind the above handler, we need to run:

  `require('carbon.watcher').off('*', my_callback)`

  At this point it becomes very clear why passing a closure will not work.
  This design should feel similar to the `window.addEventListener` API
  (https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener).

  `------------------------------------------------------------------------------`
  off                                                         *carbon-watcher-off*

  Signature: `require('carbon.watcher').off(`{event}, {callback}`)`

  This method accepts the same exact arguments as |carbon-watcher-on| but
  instead of registering {callback} for {event}, it removes {callback}
  from all {event}. See |carbon-watcher-on-callback| for an example using `off`.

  `------------------------------------------------------------------------------`
  emit                                                       *carbon-watcher-emit*

  Signature: `require('carbon.watcher').emit(`{event}, {...}`)`

  Emits {event} with {event} and {...} as arguments to registered callbacks.
  The {event} can only be one of |carbon-watcher-event-names|, unlike
  |carbon-watcher-on| or |carbon-watcher-off| which support some shortcuts.

  `------------------------------------------------------------------------------`
  clear                                                     *carbon-watcher-clear*

  Signature: `require('carbon.watcher').clear()`

  This method calls |carbon-watcher-release| on all paths registered using
  |carbon-watcher-register|. This unregisters all the paths but leaves the
  callbacks intact.

  `------------------------------------------------------------------------------`
  release                                                 *carbon-watcher-release*

  Signature: `require('carbon.watcher').release(`{path}`)`

  Unregister a {path} registered by |carbon-watcher-register|. If {path} is not
  registered this will result in a no-op.

  `------------------------------------------------------------------------------`
  register                                               *carbon-watcher-register*

  Signature: `require('carbon.watcher').register(`{path}`)`

  Register an absolute {path}. Once registered, any changes made to this path
  will emit events based on events received from Neovim's lua libuv api
  |vim.loop|.

================================================================================
SETTINGS                                                         *carbon-settings*

  `------------------------------------------------------------------------------`
  compress                                               *carbon-setting-compress*

  Default: `true`

  When enabled, allows Carbon to compress deeply nested children as long as
  they only contain a single child. For example, take the following structure:

  `pwd`
  `|-- a/`
  `|-- |-- b/`
  `|-- |-- |-- c/`
  `|-- |-- |-- |-- d.txt`
  `|-- t/`
  `|-- |-- u/`
  `|-- |-- |-- v.txt`
  `|-- |-- |-- w.txt`
  `|-- |-- x/`
  `|-- |-- |-- y/`
  `|-- |-- |-- |-- z.txt`

  We can see here that `a/` contains a single child `b/` which contains a
  single child `c/` which contains a single child `d.txt`. We can also see
  that `t/` contains two children, `u/` which contains `v.txt` and `w.txt`, and `x/`
  which contains a single child `y` which contains a single child `z.txt`. When
  compression is enabled, Carbon shows the above structure like this:

  `pwd/`
  `  a/b/c/d.txt`
  `+ v/`

  Because `a/`, `b/`, `c/`, and `d.txt` are all only children of their parent,
  this path can be compressed to the point where we can directly see `d.txt`
  even though it is nested quite deep in the directory tree. For the other
  directory `t/` however, no compression can take place at the top level
  because `t/` itself contains two children. If we open `t/` however, you will
  see the following:

  `pwd/`
  `  a/b/c/d.txt`
  `- t/`
  `  + u/`
  `    x/y/z.txt`

  We see here that `u/` is not expanded because it contains two children,
  `v.txt` and `w.txt` whereas `x/`, `y/`, and `z.txt` are all only children of
  their parent which means those can be compressed.

  `------------------------------------------------------------------------------`
  auto_open                                             *carbon-setting-auto-open*

  Default: `true`

  When enabled and Neovim is opened with a directory path argument, Carbon's
  buffer will open immediately.

  `------------------------------------------------------------------------------`
  keep_netrw                                           *carbon-setting-keep-netrw*

  Default: `false`

  When `true` NetRW will not be harmed by Carbon. This also means that
  `Explore` and `Lexplore` are no longer aliased to `Carbon` and `Lcarbon` anymore.

  This does not prevent Carbon from showing on vim startup instead of NetRW.
  To control this behavior, see |carbon-setting-auto-open|.

  `------------------------------------------------------------------------------`
  sync_on_cd                                           *carbon-setting-sync-on-cd*

  Default: `not vim.opt.autochdir:get()`

  Disabled by default when |autochdir| is set to `1`, enabled by default when
  |autochdir| set to `0`. When enabled, Carbon listens for `:cd` commands.
  Once a `:cd` command is executed Carbon will automatically update
  |carbon-buffer-data-root| to that path.

  `------------------------------------------------------------------------------`
  sync_delay                                           *carbon-setting-sync-delay*

  Default: `30`

  The amount of milliseconds to wait before updating and rerendering the
  buffer. Carbon debounces file system events by default to reduce the amount
  of updating and rerendering.

  `------------------------------------------------------------------------------`
  sidebar_width                                     *carbon-setting-sidebar-width*

  Default: `30`

  The width in columns of the sidebar window opened by |Lcarbon|.

  `------------------------------------------------------------------------------`
  exclude                                                 *carbon-setting-exclude*

  Default:
    `{`
    `  '~$',`
    `  '#$',`
    `  '%.git$',`
    `  '%.bak$',`
    `  '%.rbc$',`
    `  '%.class$',`
    `  '%.sw[a-p]$',`
    `  '%.py[cod]$',`
    `  '%.Trashes$',`
    `  '%.DS_Store$',`
    `  'Thumbs%.db$',`
    `  '__pycache__',`
    `  'node_modules',`
    `}`

  Paths matching any lua pattern are filtered removed. For more information
  about these patterns, see: https://www.lua.org/pil/20.2.html.
  This setting may be set to `nil` to show everything.

  `------------------------------------------------------------------------------`
  indicators                                           *carbon-setting-indicators*

  Default:
    `{`
    `  expand = '+',`                             *carbon-setting-indicators-expand*
    `  collapse = '-',`                         *carbon-setting-indicators-collapse*
    `}`

  Controls the expand and collapse indicators shown before a directory. Using
  more than one character is allowed. Use `' '` to remove an indicator.

  `------------------------------------------------------------------------------`
  actions                                                 *carbon-setting-actions*

  Default:
    `{`
    `  up = '[',`                                        *carbon-setting-actions-up*
    `  down = ']',`                                    *carbon-setting-actions-down*
    `  edit = '<cr>',`                                 *carbon-setting-actions-edit*
    `  reset = '.',`                                  *carbon-setting-actions-reset*
    `  split = '<c-x>',`                              *carbon-setting-actions-split*
    `  vsplit = '<c-v>',`                            *carbon-setting-actions-vsplit*
    `}`

  Default mappings for |carbon-plugs|. Setting this to `nil` will prevent
  Carbon from creating any mapping. Setting one of its properties to `nil`
  will disable the mapping for that specific property. Each property maps
  to a |<Plug>| mapping defined in |carbon-plugs|:

  `up`      =>  |carbon-plug-up|
  `down`    =>  |carbon-plug-down|
  `edit`    =>  |carbon-plug-edit|
  `reset`   =>  |carbon-plug-reset|
  `split`   =>  |carbon-plug-split|
  `vsplit`  =>  |carbon-plug-vsplit|

  `------------------------------------------------------------------------------`
  highlights                                           *carbon-setting-highlights*

  Default:
    `highlights = {`
    `  CarbonDir = {`                          *carbon-setting-highlights-CarbonDir*
    `    ctermfg = 'DarkBlue',`
    `    guifg = '#00aaff',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonFile = {`                        *carbon-setting-highlights-CarbonFile*
    `    ctermfg = 'LightGray',`
    `    guifg = '#f8f8f8',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonExe = {`                          *carbon-setting-highlights-CarbonExe*
    `    ctermfg = 'Green',`
    `    guifg = '#22cc22',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonSymlink = {`                  *carbon-setting-highlights-CarbonSymlink*
    `    ctermfg = 'Magenta',`
    `    guifg = '#d77ee0',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonBrokenSymlink = {`      *carbon-setting-highlights-CarbonBrokenSymlink*
    `    ctermfg = 'Brown',`
    `    guifg = '#ea871e',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonIndicator = {`              *carbon-settings-highlight-CarbonIndicator*
    `    ctermfg = 'DarkGray',`
    `    guifg = 'Gray',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `}`

  The full highlighting configuration used by Carbon. Each key of this table
  will become a highlight group. The table of properties attached to each key will
  determine how the final generated highlight group will look. Any valid
  property of |highlight| commands is also valid in this table.

vim:ft=help
